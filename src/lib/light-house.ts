import React, { useState } from "react";
import lighthouse from "@lighthouse-web3/sdk";
import axios from "axios";
import { BigNumber, ethers } from "ethers";

// Define your API Key (should be replaced with secure environment variables in production)
const apiKey = process.env.LIGHTHOUSE_APIKEY as string;

// Function to sign the authentication message using Wallet
export const signAuthMessage = async () => {
  //@ts-ignore
  if (window.ethereum as ethers.providers.ExternalProvider) {
    try {
      //@ts-ignore
      const accounts = await window.ethereum.request({
        method: "eth_requestAccounts",
      });
      if (accounts.length === 0) {
        throw new Error("No accounts returned from Wallet.");
      }
      const signerAddress = accounts[0];
      const { message } = (await lighthouse.getAuthMessage(signerAddress)).data;
      //@ts-ignore
      const signature = await window.ethereum.request({
        method: "personal_sign",
        params: [message, signerAddress],
      });
      console.log({ signature, signerAddress });
      return { signature, signerAddress };
    } catch (error) {
      console.error("Error signing message with Wallet", error);
      return null;
    }
  }
};

// Function to upload the encrypted file
export const uploadEncryptedFile = async (file: any) => {
  try {
    // This signature is used for authentication with encryption nodes
    // If you want to avoid signatures on every upload refer to JWT part of encryption authentication section
    const encryptionAuth = await signAuthMessage();
    if (!encryptionAuth) {
      console.error("Failed to sign the message.");
      return;
    }

    const { signature, signerAddress } = encryptionAuth;

    // Upload file with encryption
    if (apiKey) {
      console.log("here");
      console.log(apiKey);
      console.log({ file });
      console.log(signature);
      console.log(signerAddress);
      const output = await lighthouse.uploadEncrypted(
        file,
        apiKey,
        signerAddress,
        signature,
        progressCallback
      );

      console.log("Encrypted File Status:", output);

      /* Sample Response
        {
          data: [
            Hash: "QmbMkjvpG4LjE5obPCcE6p79tqnfy6bzgYLBoeWx5PAcso",
            Name: "izanami.jpeg",
            Size: "174111"
          ]
        }
      */
      // If successful, log the URL for accessing the file
      console.log(
        `Decrypt at https://decrypt.mesh3.network/evm/${output.data[0].Hash}`
      );
      return output;
      // return response;
    }
  } catch (error) {
    console.error("Error uploading encrypted file:", error);
  }
};

const signAuthMsg = async (privateKey: string, verificationMessage: string) => {
  const signer = new ethers.Wallet(privateKey);
  const signedMessage = await signer.signMessage(verificationMessage);
  return signedMessage;
};

export const getApiKey = async () => {
  const wallet = {
    publicKey: "0xe57F24E3c9C5bE617E6D330D2B2308926188e398", // Ex: '0xEaF4E24ffC1A2f53c07839a74966A6611b8Cb8A1'
    privateKey:
      "W584799f49952962b0022fff8ada7e36d319b0578b6809f2ffcf540b227673cf5",
  };
  console.log({ wallet });
  const verificationMessage = (
    await axios.get(
      `https://api.lighthouse.storage/api/auth/get_message?publicKey=${wallet.publicKey}`
    )
  ).data;
  console.log({ verificationMessage });

  const signedMessage = await signAuthMsg(
    wallet.privateKey,
    verificationMessage
  );
  console.log({ signedMessage });
  const response = await lighthouse.getApiKey(wallet.publicKey, signedMessage);
  console.log(response);
};

const progressCallback = (progressData: any) => {
  let percentageDone = (progressData?.uploaded / progressData?.total) * 100;
  console.log(percentageDone);
};
export const shareFile = async (
  Hash: string,
  party1Address: string,

  accessAddresses:string[]
) => {
  try {
    // CID of the encrypted file that you want to share
    // CID is generated by uploading a file with encryption
    // Only the owner of the file can share it with another wallet address
    const cid = Hash; // Example: "Qma7Na9sEdeM6aQeu6bUFW54HktNnW2k8g226VunXBhrn7";
    const publicKey = party1Address; // Example: "0xa3c960b3ba29367ecbcaf1430452c6cd7516f588";

    const publicKeyUserB = accessAddresses; //Example: 0x487fc2fE07c593EAb555729c3DD6dF85020B5160
console.log({cid})
console.log(publicKey)

console.log(publicKeyUserB)
  const encryptionAuth = await signAuthMessage();
    const shareResponse = await lighthouse.shareFile(
      publicKey,
      publicKeyUserB,
      cid,
      encryptionAuth?.signature
    );

    console.log(shareResponse);
    /* Sample Response
      {
        data: {
          cid: 'QmTsC1UxihvZYBcrA36DGpikiyR8ShosCcygKojHVdjpGd',
          shareTo: [ '0x487fc2fE07c593EAb555729c3DD6dF85020B5160' ],
          status: 'Success'
        }
      }
    */
  } catch (error) {
    console.log(error);
  }
};

